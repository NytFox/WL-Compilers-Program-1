::::::::::::::
main.c
::::::::::::::
#include "defs.h"


/*  global variable(s), used in the compiler  */
int const_value;

main()
{
        int yyparse();

	/*  first we set up any initialization necessary for the compiler  */

	initialize_symbol_table();

	/*  We MIGHT have some code here to spit out any "formatting" that
            the output (assembler ?) requires  before the "real" code
            things like .csect commands, .text,  etc. */

	/*  yyparse is the name of the parser.  It parses the program, and
            allows us to spit out code during the parse.  */
        
	return(yyparse());

	/*  Having compiled the program an spit out the code, we might need
	    to add some postscript to the assembler output --- space statements,
	    etc.  */
}

::::::::::::::
lex.l
::::::::::::::
Digit		[0-9]
Letter		[a-zA-Z]
IntLit		{Digit}+

%{
#include "defs.h"
#include "y.tab.h"
%}

%%
[ \t\n]+				{ /* delete */		}
{Letter}({Letter}|{Digit}|_)*		{ process_id();
					  return (ID);		}
{IntLit}				{ yylval.intstuff = atoi(yytext);
				          return (INTLITERAL);	}
":="					{ return (ASG);		}
";"					{ return (';');		}
"+"					{ return ('+');		}
%%
process_id()
{
	/*  The following uses a chained hash table implementation of
            a symbol table.  Each "bucket" of the hash table consists
            of a list.  Each element of THOSE lists (Nodes) contain
	    a field "stuff" which has the acutal symbol table goodies,
	    like a character string "key" and an integer "register number."
	*/

	Node list_node;
	SymbolTableElement symbol_table_node;
	if( ! (list_node = search_table(yytext) ) )
	{
	   /*  a symbol table entry has a character string "key" taken
               from yytext, and a register "number", in the range 4-31.  */

		symbol_table_node = create_symbol_table_entry(
			yytext,assign_next_register());
		insert_in_table(symbol_table_node);
	}
	else
	{
	    /* the identifier (whose name is stored in yytext) is already
               in the symbol table.  */

		symbol_table_node = list_node->stuff;
	}
	yylval.symbolstuff = symbol_table_node;
}

int assign_next_register()
{
	/* The compiler allocates each variable to a different machine
           register.  This routine just chooses the next register in
           the range r4 to r31.  Registers r0-r3 are reserved for other
           purposes  */

	static int register_number;
	register_number = (register_number + 1) % 28;
	return register_number + 4;
}

::::::::::::::
gram.y
::::::::::::::
%{
#include "defs.h"
%}

%union 
{
        int intstuff;
        char *stringstuff;
        SymbolTableElement symbolstuff;  
}

%token ASG 
%token <intstuff> INTLITERAL
%token <symbolstuff> ID

%type <stringstuff> expression 
%type <stringstuff> statement statement_list
%start statement_list
%%
statement_list  :  statement_list statement
                | statement
                ;

statement  :  ID ASG INTLITERAL ';' 
		{ 
			$$ = $1->s;
			generate_copy($1,$3);
		}
	   |  ID ASG expression ';' 
		{ 
			$$ = $1->s; 
			generate_exp($1,$3);
		}
   ;

expression : expression add_op INTLITERAL 
		{
		   /* printf("\nWe're adding a constant, %d\n\n",$3); */
			const_value += $3;
		}
	   | ID
		{ 
		   /* printf("We've seen an ID starting an expression\n"); */
			const_value = 0;
			$$ = start_expression_string($1);
		}
   ;

add_op : '+'
   ;
%%

generate_copy(symbol,value)
	SymbolTableElement symbol;
	int value;
{
	/*  write a statment of the form 
		
		oril	#,r0,rd   
	    
	    where # is an integer constant constant  and
	    rd is the destination register.  r0 is always 
	      0 in this architecture.
	*/

	printf("oril %d,r0,r%d\n",value,symbol->offset);
}


generate_exp(symbol,rhs)
	SymbolTableElement symbol;
	char *rhs;
{
	/*  write a statment of the form 
		
		ai	rs,#,rd   
	    
	    where # is an integer constant constant,  
	    rs is the source register and
	    rd is the destination register.
	*/

	printf("ai   %s,%d,r%d\n",rhs,const_value,symbol->offset);
}


char *start_expression_string(symbol)
	SymbolTableElement symbol;
{
	char buffer[10];
	char *result;
	result = malloc(4);	/*  tacky, but should be big enuff  */

	strcpy(result,"r");
	sprintf(buffer,"%d",symbol->offset);
	strcat(result,buffer);

	return result;
}
	
yyerror(s)
char *s;
{
        fflush(stdout);
        printf("Syntax Error %s\n",s);
}

